 Hi, let's start. Welcome. How are you doing with the lab? Almost finished? Hard? Very hard? Hopefully it wasn't too hard. So it's Wednesday, so we're going to do a theory lecture. It's actually something that we're going to spend the next two lectures, so this Wednesday is the next Wednesday, the topic, which is finite automata and regular expressions. How many of you know finite automata? Have you done them before? Sometimes it's covered in 208. It's one of the materials. So if you've seen this before, it's going to get easier for you. If you haven't, don't worry. That's what this is for. This lecture is going to have a lot of technical formal material. So I want to start with just giving you an explanation of why we do it. What are we trying to get out of it? So first of all, what's our context? Our context is still Lexing. Remember that in order to do Lexing, you need to know what the tokens are. The easiest way to specify what are the possible tokens and what are the streamest tokens is a regular expression. But then you don't need the regular expression. You actually need code that does the Lexing. In the lab, you've seen the Lexer. I know some of you looked into how the Lexer is implemented. It's a piece of code. Somebody written it. That goes through the input stream, figures out it's a bunch of tokens and breaks them down. This is what we want to learn how to do. Now in that lab, a Lexer is written by somebody who looked at the regular expressions and just figures it out. But we can do better. What we can actually do is we can generate the Lexer directly from the regular expression. We can generate code for it and we can generate very efficient code. This is what this is for. Now in order to do this, we're going to need several things in order to be able to do the Lexer automatically. The fun thing from the compiler course perspective is that that's in itself a mini compiler. It's a mini compiler that goes from a regular expression, that's something that you've already seen, the declarative definition of a language, into a program that does Lexing. Now in a specific case, we're not going to do the Lexing part, we're just going to do the recognizing part, not actually figuring out where the tokens begin and end. Once you have a recognizer, getting a Lexer out of it is easy. So we're focusing on this. And the first question, if we're going to compile, is what are we going to compile into? So we start with regular expressions. We want to get a Lexer. In what language? We could study how to generate a Lexer in Java, in Rust, in C++, in C. But clearly, this problem is fundamentally independent of the language. So we would like to have some kind of assembly language we can compile into that is not any of our surface languages. And it's just good enough for representing what we need. Not too complicated. If it's just good enough, it's going to be a very simple language. We'll be able to simulate it in other languages, so we can easily convert from that language to Java or whatever. And when we talk about that we would like to get the most efficient implementation in this language, it will be easier for us to talk what's efficient and what isn't if the language is simple. So this is where finite automata comes in. So our input is a regular expression. The output of our procedure will be a deterministic finite automata. A deterministic finite automata is essentially a specialized programming language. Very simple. Kind of like a circuit. That's roughly what it represents. That has the following operation. It reads a bunch of a string, a character at a time. It operates on that string, does something, something, something. Whenever we get to the end of that string it says, that string is good, accept. Oh, this string is bad, reject. What we want to be able to do is give an irregular expression, whatever it is. We want to construct a program in this finite automata language that says accept whenever an input string matches a regular expression, reject where it does not. Now this deterministic finite automata as a language will be our lowest level. Which means what's important about it is that it's really easy to execute. Really easy to simulate. As with any low level language, what will be difficult in it is... We're not going to debug, we're going to generate, but yeah. Debugging or even just writing stuff in it will be difficult because it's so low level it's just going to be very verbose. That's what you should expect. Now in order to make this nicer, and again, you'll see this better on this slide later, but just to give you a precursor. The way it's going to work is we're going to go from regular expressions to automata, not to deterministic because they're too low level. Something called non-deterministic automata, which will have the structure of a program, that it will have some wishful steps, steps that ask an oracle to help it do the execution. And then we're going to compile from that representation into this deterministic automata. And that's going to give us something that is correct, but quite large in terms of the number of states, the size, it'll just be big and... And it will have a lot of redundancy. And then we look at an algorithm how to minimize it, how to give in one program to construct another program that has exactly the same behavior. So one DFA, you get another DFA that has exactly the same behavior, but has the least amount of structure, the smallest possible. And so then the end result will be a compiler from regular expressions to as small as possible programs that recognize it. Now this is going to take us two lectures, so it'll take us some time. A big chunk of this lecture will be just lots of definitions. I have to teach you a language. And as you know, if you want to learn a new programming language, initially you just have to gather a lot of concepts. They're not very hard, it's just a lot of them. And the second thing that I'm going to try and do is to give you intuition. So these things, this is how they look like. They're kind of circuits. We usually draw them with circles and arrows and things like that. That's something that's very easy to execute. It's something that's not very easy to think about. Some people find that actually quite convenient way to think as a mechanism. But I don't, and I think many people don't. At the same time, you're all really good at programming. To some extent. At least you've done this. I'm sure that many of you have written programs more than try to write an automaton. I'm going to show you how you can think about automaton as programs. They're just a different language for writing programs. Which means whenever you need to create an automaton, one way to do it is to forget about the automaton. Think of a program and then in your head compile the program down to an automaton. And so this is, my goal here is to give you this intuition. But first let's look at what they actually are. So we have this one automaton in here. Everything that's in black is an automaton. Everything that's in blue is just an explanation. So let's talk about the different pieces. First we have this incoming arrow. Arrow that goes out of nowhere. That's an entry point. That's how we say this is the main of the automaton. The automaton starts in bubble q0. The bubbles are called states. They represent various places where an automaton can be. This one has six states. Each state is labeled with a letter and a transition. The meaning of this is that if an automaton reads this letter in an input, it takes a transition that's labeled by this letter. Also in order to make this meaningful, I have to tell you what letters there are. This is called an alphabet. And from this picture we can see there's only two letters a and b. Now this automaton is deterministic, which means it's completely unambiguous. At every state, for every letter, there is an error. And exactly one error. So you never have to worry about what do I do when something is confusing, an error is missing, or there's too many errors. We'll see structures like this. In a deterministic automaton it's very simple. What an automaton does, given a string, reads one input and then moves. Reads the next input and then moves. For example, let's say I have an input a, b, a. And I want to execute this automaton on this input. I want to know whether this automaton will recognize this input or will say this input is not something that I like. I'm going to start here at q0. I'm going to start here at my first symbol. I read the symbol. What symbol do I read? A. I'm looking at my q0. I look for an arrow with a. Where does it go? q1. So I move. I move to q1. I read the next input. I see b. On b I move to q2. I go here. I read the next symbol. It's a. If this is an end of an input, I'm somewhere. Now I get to say whether I accept or not. If I'm in an accepting state, which is the state marked by double circle, then I say yes. If I'm in a state that doesn't have a double circle, then I say no. That's it. Does this automaton accept the string? No. Because I got into q5, q5 is not a double circle state. There is no more input. Reject. Can you find a string that this automaton would accept? A, B, B, A. Take this path to q4. Stays at q4. Accepts. If given an automaton you want to find a string that it accepts, you find an accepting state. It could be one, like here, or multiple. You take a path to it. The path could be direct or could go through a loop. And you just read off the letters that are on that path. Is there another string that this automaton accepts? No. There's only one path to q4. Everything else goes to q5. I will say this string is the language of this automaton. This automaton represents the regular expression A, B, B, A. Or this automaton represents the string A, B, B, A. This whole thing is just exactly the same thing as this string. The interesting part is that I'll claim that if you ever want to get a recognizer for regular expression, you can always write it as a structure like that. There's always an automaton. No matter how complicated the regular expression is, there will always be an automaton for it. The other way is also true. You can also decompile. Given any automaton, it's possible to construct a regular expression that corresponds for it. So you can compile regular expressions into automata. This is what we're interested in here. You can also decompile automata into regular expressions. Something that's fun to know, not part of this course. Now, one thing to point out in this picture. So it says there's initial state, the one with an error, a state which is a bubble, a transition which is an error, an accepting state which is a double circle. There's also something called an error state, sometimes called a sink state, sometimes called a trap state. That thing, the error state, the sink state, the trap state, that's not something that's part of an automaton. All the other parts will be. That other thing is just our intuitive meaning for a structure like state q5. The interesting thing about the structure q5, that single state, sometimes it's multiple, is once you get into it, you cannot get out. And once you're stuck in it, you can never accept. So we call it an error state or a sink state or a trap state. Basically, to say if an automaton ever gets to there, we don't really care what happens afterwards, because we're just going to get stuck. But we don't have any, we need to discover this by looking at transitions. Rather than, for example, an initial state will be explicitly named. So hopefully the structure is clear. That's it. That's basically all that we have to do today. Now, an intuition. So what kind of program is that? So if I were asking you to write a program corresponding to an automaton. We know what the input, you get a string as an input. We know what you're allowed to do in that program. You read one element from an input. You adjust some variables. You read the next. And then at the end, whenever you get end of file, you have to say accept or reject. Some of those programs can be converted into automaton. There are some features of programming languages that can be compiled into an automaton. And some features that cannot. So can you figure out what features? Well, let me help you. Can you have a loop? We have a loop. Loops in a program seem to correspond to loops in an automaton. We can think of each automaton state as a line in our program. And each transition is a go-to. And we can go back because we can have a transition from one state back to some previous one or to itself. So loop seems okay. So it's programmed with loops. Now, this automaton at any point gets to look at the next letter and make a decision. So something like a switch or an if would also be okay. So we can use ifs and we can use loops. What other programming concepts do you know? Can we use classes? And objects? Maybe, but they're not essential. Right? Like we need to know from the algorithmic perspective what is the core. And we know everything we can write with classes and objects. We can write maybe more remotely without. So we don't need to worry about this. But what other features? Well, in my programs whenever I have ifs and loops I usually have some data. I usually have some variables. So what kind of variables can I have? So say I have a program with Boolean variables. I have a program with five lines and two Boolean variables. Can I compile it to an automaton? Well, let's see. So automaton have states. States represent everything, like the whole memory of an automaton. When an automaton is in a given state, I said that's a line number in a program, but I lied. It's really a line number of a program plus the values of all the variables. So if I have a program that has five lines, each line has an instruction, and the program has two Boolean variables, how many different states can I be? More? So if I have five lines, I can be in a first line, second line, you know, five lines, but I also have variables. So? Hmm? 10. 10. More? 20. I have two Boolean variables, each one is true or false. That's four. I have five lines times five. That's 20. So my state will be, I am in line five on my program, my first Boolean variable is true, my second Boolean variable is false. I look at the next input, and I transition. How do I transition? I run my instruction. The instruction changes the line number and changes my Boolean variable in some way. I look up a state that corresponds to this change, I jump there. So, finite state means that I have finitely many finite sized variables. Alright, so that's almost all the features of a typical programming language. What am I leaving out? Dynamic memory. I don't like dynamic memory because it's easy to not quite know how many states do I need, how much memory I use. I can have some dynamic memory where actually it's just finite, just large. That would be fine. But I may end up by mistake using too much dynamic memory. So usually it's easiest to say no dynamic memory, just a bunch of Boolean variables. So what else? So that also means no complicated data structures like hash tables or any of those things. What else? What else? If you can construct a non-deterministic program, you will make lots and lots of money. We don't know how to do that. All of our programs are deterministic. Or you can have any kind of input too. Non-deterministic means that on one input you do multiple things and you don't know which one you're going to do. And you're guaranteed to do the one that will solve the problem. That's why it's so hard. Like there's random probabilistic programs but there aren't non-deterministic ones. The only way we get non-determinism is because we say what actually will happen is too hard. So I pretend it's non-deterministic and then I see whether I can still reason about it. So for example, when we talk about concurrency, we say a concurrent program is non-deterministic because I don't know which thread will get scheduled next. But really if I look at the operating system scheduler, I know exactly which thread will be scheduled next. It's not a non-deterministic choice. So the real program is always deterministic. Sometimes we pretend to think about them as non-deterministic. While loops are fine. Is that loops? Wow, I guess your programming experience is very different from mine. So in almost all of my programs I use functions. That's the thing that you're missing. So here are no functions. More specifically, no recursive functions. If you have functions that you can inline, that's fine. That's just the convenience. That's a macro. A recursive function gives you the power of having arbitrary amount of memory. Each time you recurse, you have new local variables. So you can count by increasing recursion. So, and back to what this thing is. All of this is, is just a very specific way to represent a program with Boolean variables, arbitrary control structure, arbitrary loops. So if you ever need to construct an automaton, you have a question somewhere that says, can you write an automaton that does it? Blah. Recognizes a particular string. And you don't know quite how to do it. Then one way to do it is you start thinking, can I write a program that recognizes that string? And limit yourself to just write a program as one function that only uses Boolean variables for its state. Kind of loops and ips. And if you can, then you can compile your program down to an automaton. The automaton will just be the state space of this program. So that's an interesting thing about regular expressions. So regular expressions is everything for which you can write a recognizer with very limited amount of memory. And therefore it's going to be very efficient. Moreover, if there is some kind of string for which, some kind of language for which you can write a recognizer with small amount of memory and just loops and ips, that's something that you can represent by regular expression. They're the same thing. There's no reason not to use regular expressions. They're just a declarative way for this very efficient program. Now just to test your understanding of this, let's do the following exercise. Now we note again, this is not a theory class. Not like 208, for example. So we're only touching on some of the things that we really care about compilation. But we need to understand a bit of a theory just to get some intuition of why certain things work the way they are. So there is a very commonly used language to show how can you have something that is not possible to do with an automaton. And the simplest language like that is a language over again the alphabet AB, where I am accepting a string, it's good, if number of As and number of Bs in that string is the same. Now this is often called, and we'll talk about this another time, often called the language of open and close parentheses. Often it's restricted even more because we'll say A is an open parenthesis, B is a closed parenthesis, and we want to know that they're all match. But a simpler version, I just have As and Bs, I just need to make sure the number of As and numbers of Bs is the same. Now I claim it's not possible to recognize this language by a finite automaton. I'm not going to do the proof here, but I just want to get you to do the intuition of why this would be difficult. So what's the difficulty of recognizing a string, number of As equals number of Bs, using a finite automaton? The way I want you to try and solve this is give me a program that does it, and then let's analyze whether this program fits a finite automaton or not. And once we discover why it doesn't, it will give us an intuition, so what's the challenge? So who can write a program that reads a string and says yes if number of As and numbers of Bs are the same, and false if it isn't? Anybody? Yay, some people can. How will your program look like? Can you say the counter? Easy, right? Counter. We can do one counter that goes up and down. If you want to use only positive numbers, we'll have two counters, As and Bs, and then we compare. Easy, great. There's nothing in this program, there's no functions, complicated data structures. The only thing that I said, you can't really use counters. You have to use Boolean variables. So how can we replace a counter by Boolean variables? Are you in ECE? Or have you heard of machine arithmetic? Yeah, bits. So we replace a counter by a bunch of bits. Whenever we want to add, we use another circuit. Just flip bits. Easy. So we take in this thing. And then we have one counter for A, one counter for B. When I say counter, I really mean a machine integer. Which one? Which machine integer should I use for the counter of number of A's? Well, on my machine, usually when I say I want to use a machine integer, if you program at a low enough level language, it will tell you you want U32, U64, 128 bits. How big an integer do you want? What do many of you don't know? So that's a problem. So I said that we can use counters as long as we can represent them by Boolean variables. We say, oh, that's easy. We can just use machine integers. But if we use machine integers, we need to know the size. But here, if we need to count how many A's we'll have in an input, because we don't know the size of an input a priori, any bound that we pick may not be big enough. So your counter is, in fact, uses arbitrary amount of memory. So if you were to actually implement this on a machine, you would say, I can't use I32, I can't use U32. I need an arbitrary precision integer. And if you go into an implementation of an arbitrary precision integer, it will say, well, whenever I run out of bits, I'll locate more memory dynamically and use more and more and more. So this is why it's difficult or impossible to create a finite automaton that accepts, say, the same number of A's as number of bits. That's not a proof because we just tried to build one and failed. Hopefully there's another way, I'm telling you there isn't. But hopefully this gives you an intuition of how to solve this kind of problem. You come up with a simple solution without worrying too much and then you check every gadget that you use, you check that, in fact, you can compile it down to a circuit. And if you can, then you get an automaton. That's it. If we're going to take his solution and then we say I can compile it to an automaton, the first thing that I have to ask is how many states do I have to create. Because I have to create all the possible states. Some of them may be used, some may not, but I need to create all of them first. And I fail because I have to say, oh, for two integers, so how many states can I get if I have two integers? And he says, well, I won't tell you how wide they are. And now I'm stuck. And now I discovered the simple idea that I have a counter actually says infinite amount of memory. Even so, it doesn't look like I do dynamic allocation. I do. Any questions? All right. So from this point on, all we need to do is just go through a few examples, get a few definitions, and then compile, compile into it. So this is just animation of what we just talked about. If you want to see how the execute, we just went over it. Again, accepting only happens at the end, so we read the whole string and then we're either in an accepting state or we're in a rejecting state. Let's see this guy. What is the language accepted by this automative? What strings are accepted? So here, there's one extra strange thing. So we start with q0. q0 is accepting. That's where we start, which means if there's nothing else in the input, we say yes. That means we're going to accept an empty string. We need some kind of notation for an empty string. And unfortunately, or likely fast, there's two. One is this Greek symbol lambda. That means empty string. Another one is this Greek symbol epsilon. Also means empty string. Now, for some reason, which I actually don't know, both of them are used commonly. And for you, in the slides, I use lambda. And in the notes, we use epsilon. So lambda, epsilon will be interchangeable in the class. They mean empty string. We need a special symbol. Otherwise, there's no way for us to say it's empty. And of course, that special symbol should not be one of our letters so we don't get confused. So it's definitely not a or b or some other symbols. So it's a Greek letter. So that's one. If we go to q2, the only way to get to q2 is a, b. So that's also accepted. If we go to q4, the only way to get there is through a, b, b, a. That's also accepted. There's no more accepting states. Therefore, any other string goes not to an accepting state that is rejected. So the language is just this. An automaton can have more than one string that it accepts. Hold this. Can you change this automaton so that it accepts a language that has infinitely many strings? How would you do that? To do this, you have to change something so that there is more than one way to get to an accepting state and actually that there's infinitely many ways to get to an accepting state. Well, if you have a finite graph and you want to have infinitely many paths in that graph, you have to have a cycle. Help me add a cycle in here. Hmm? Just make q5 easier. Too easy. Do something else. Very good. If I ask this on an exam, that's a very good solution. You just make q5 accepting. You say, look, it accepts now everything. Take one. Hmm? So the suggestion is to do this, right? To add a self-loop here on a. Yeah? You're going to have a self-loop. A loop in another direction. It doesn't have to. A self-loop is easy. Now, an important thing here is that right now I've broken. This is no longer a DFA. It's no longer a deterministic automaton. Because when I'm in q1 and I see a, I don't know where to go. So it's really important if I want to change something. If I've broken it, I have to fix it. So there was also a suggestion that actually this transition that you had, you have to redirect. It's not just that you add a loop to make sure that you remove something. So now this is a DFA. What did we do to the language? An empty string is still in. That's simply because we didn't change the q0 state. The string ab is still in. We didn't change how you can get to q2. You could still get the old way. We didn't change abba. Still can get to q4. But we added things. So what other string now we accept? So let's say a, a, b. Is that accepted? Yeah, because we can loop on q1 to eat the extra a. What about a, a, a, b? Who wants to see me write infinitely many strings? Do you know a concise way to write infinitely many strings? Oh, a regular expression. So what would? Maybe it's not a star but a plus b. That's everything that's accepted at q2. It's a plus because I have to have at least one a. Then I loop on a's. And then I have go to b. But of course, from there, I can also go further. So I can accept stuff at q4, which will be a plus b, ba. This is all the string that I accepted at q4. This will be my language. This is obviously not a very concise way to represent the language. I can play and get a better regular expression. Decompilation is hard. I can improve it. But this is a correct enough result. What does this automaton accept? What does this automaton accept? We have to get to q1. That needs a b. We have a loop on a. That's a star. And if we have anything else after b, now we don't accept. Again, there's examples here to show you how this works. And whenever we can't come up with a regular expression, if we need to write a language, we can use this notation, where we use a little bit of a math to try and say what it is. So this is the same thing. It says a whole bunch of a's followed by b, where the whole bunch of a's is n, where n is greater or equal than 0. So it could be 0 or more. How about this one? This one is interesting. So this one is interesting because its alphabet is only one symbol. It's only one. Which means this automaton, if it accepts anything, it accepts the string of a bunch of ones. So we can differentiate such strings by their length, not by their content, because they're just one. So what does this one accept? Say we do an empty string. Is that accepted? Yes, because the initial state is accepting that. A single one. Two ones. Three ones. Four ones. Four ones. So it accepts anything if the number of ones is given. How do you come up with an automaton like that? So say I ask you, can you come up with an automaton that accepts a string only if the number of ones is divisible by three? How would you come up with that one? Divisible by seven. What would be a trick? Divisible by seven. So you are thinking as a regular expression expert, But you are mostly programmer experts, not automaton experts. Yeah, but this is you thinking as a regular expression expert, as an automaton expert, but you're mostly programmer experts, not automaton experts. How would you do it as a programmer? So more general, you would use a counter, modular whatever lens I need. If I want to do all strings whose lens is divisible by 7, I have a counter mod 7. I keep incrementing it every time I see something. Whenever it gets to 7, I zero it out. If at the end of a string it's 0, I say yes. Otherwise, I say no. This is what the two states of the automaton are. The first one says I've seen 0 once. The second one, I've seen odd number once. I count your 1. I go back, reset, back. All right. So I'm going to do a formal definition, and then we're going to do another example. I've shown you this automaton sort of intuitively, and I've shown them to you as a picture. Of course, whenever we're going to compile them, we need to produce them actually. We're not good enough to do just the picture. So we need a formal definition of what they actually are. This is just going to capture what you already know from the pictures, but in terms of letters. So an automaton is this tuple. So I have a string, how the circuit is described. I have q, which is how many states I have, a name for every state. I have sigma, which is my alphabet, what can appear on transitions, what is allowed. I have a special symbol, empty, that is not part of my alphabet. I have q, the initial state, and just one element of q tells me where I start. I have f, which is a set of states that tells me where do I accept. And then I have my transition relation, a transition function, delta, which is going to be a big table that will tell me, given this state and given this input, that's where you go. So just to connect it to the picture, if I have to describe this automaton formally, my state space q is, just at least all the states. My alphabet, well, I only see a and b on the transition. My initial state is just q0. My accepting state, well, this is just one, just q4. And my transition relation, in this case, because the automaton is deterministic, the transition relation is a function. Given a state and a letter, there's only one output, one place to go. And it will be described to me as a table. When I think about that I want to compile and produce an automaton, I'm thinking that I have to produce this table. And basically, from this table, you know what the state space is, what the alphabet is. And then I need to indicate which states are initial and which state is acceptable. Now, in order to define what an automaton means, its semantic meaning, the language, we need to have a few extra definitions. What we're trying to do is write formally the following thing. How do I know the language of this automaton? Well, very simple. You find the accepting state. If it has multiple accepting states, you find each one. And then you find all the way you can get to them. And that's the language. We just need to write it down in some formal way. We know how to make one step. That is, apply delta. So we need to say, I can get there somehow by applying delta multiple times. And so for this, we define the thing called delta star. Its difference from delta is that its first argument is a state. But the second argument, you see it's a sigma star, means the second argument is a string. It's not a single letter, but a bunch of letters. And what delta star will do, it will start in the state. It will take the first letter from the input. It will apply delta. Because delta is a function, it's going to be in the next state. It will take that state, take the second letter, apply delta, next state, apply delta, next state. That's it. So that's, if I give you any string w, delta star of w will just get me to whatever the final state is. So here, for example, if I want to do delta star of a, b, well, easy. I start in q0, first symbol is a, I jump to q1, next symbol is b, I jump to q2, my output is q2. So just a formal definition of the same pictures I were showing you. If I wanted to communicate with you in formulas rather than pictures. And then from that, we have an extra case, what happens on an empty string. We say, if you apply delta star on an empty string, it just doesn't go anywhere. So the output is just the same as an input. So, yeah, it's just how we get somewhere. And we need this in order to give this definition. So we have our automaton, that's our machine. Its meaning is all of the strings that it accepts. This is called its language. It's something that the machine recognizes. And now we can write the formal definition, which is this guy. Which is just in symbols exactly what we were talking about so far. So if I give you an automaton and I say, well, what is its language? Your answer would be, take every possible w in the strings that are allowed. Take delta star, apply delta star on the initial state nw. See where you end up. If you end up in f, you put the w into the language. If not, you don't put the w into the language. Obviously, this is not a constructive definition because sigma star is infinite. This is just a declarative definition of what the language is. We also have a language rejected by a DFA, which is the same thing except that it's all of the strings where, when we run the automaton on them, we end up in a non-accepting. It will all be important in a bit. With this, some examples, again, of automata and their language. So on the left here, we have an automaton for an empty language, sorry, that doesn't have anything in it. It has no accepting states, so every string is rejected. And then we have its complement, which is an automaton that accepts all strings. Because it has only one state that's accepting, so everything is accepted. This is an automaton for a language of an empty string itself. It has two states. The initial one is accepting, so the empty string is accepting. And as soon as it sees any symbol, it moves into a trap state and gets stuck there and does not accept. If we want to have a language of everything but the empty string, we just sweep the change the accepting and rejecting states places. And we get the other way. Here we have an automaton that accepts all strings that start with AB. It's very easy. If you see AB, you go to Q2 and you accept. And then it doesn't matter what happens. And if along the way you see something you don't like, you go into an error state and you get stuck. So what if we wanted to have a language which is all strings without the prefix AB? So how do we complement this? So we make this state not accepting anymore. And actually we have to make every other state accepting too because strings which are short also don't have a prefix AB. An empty string doesn't have a prefix. So that's a nice trick. If an automaton is deterministic, it's very easy to complement. You just swap the accepting and rejecting states. So sometimes whenever you're trying to think of something, it's easier to think of a positive than a negative. And so you can do one and then swap. So this is an example where I want you to think given everything that we've learned. I have an alphabet 01. And I want to build an automaton for a string that accepts a string if it contains 001 as a substring. For example, this string here I want to accept actually for two different reasons because it has 001 twice. This string I don't want to accept because it doesn't have 001. What is an automaton for this? And I don't want you to answer to me by just giving me how it looks like. I want the intuition. How do you get to it? One way to construct an automaton is you just draw one and you play with it until it works. That's going to be easy for easy things. But it's just going to get arbitrarily hard for something that doesn't just work. I want you to think like programmers. Think about how you would solve this problem as a programming problem. And then compile your solution into an automaton. And then we'll see you next time. Thank you. So who thinks they can write a program that given a string finds a substring 001 in it without using string contains function and without asking chat GPT? Our co-pilot. Really? I am told that with co-pilot people will forget how to program because it will do everything for them. But we already reached that state. And create substrings. You can have a program with Boolean variables, maybe some simple counters. That's it. If you do substrings, you just have to compile them down to those counters later. So it's just too hard. There's no list significant between. What do you mean by that? I have a string of characters. And I need to know whether in that stream I see 001. So what do I XOR with? I need you to write a program that takes a sequence of characters, reads, reads, reads, reads, reads, and then says yes or no if it ever read 001. All right. It's too complicated. I mean, write track, but you're not selling at all. Sure. It sounds very similar. Just correct, but you're not selling at all. You have too many words. No, because that will happen. No. That's what we're trying to solve. So what are those enums doing? What are you doing with them? Keeping track of? Keeping track of how many zeros in a row you have seen. So if you have a counter that's just going to count how many zeros you've seen. If the counter is at any point has a high enough value and you see one, then you accept. And if it has a low enough value and you see one, then you reset it back to zero. So you need to count how many zeros you've seen in the past. And then you know if you've seen enough zeros and now the next one is a one, you accept. Or you see one when you don't expect, you reset this counter. So you have a counter. In this particular case, because I look for zero, zero, one, the counter has only value. I haven't seen anything. I've seen one zero. I've seen two zeros. That's it. That's your enum. So if I have this as my state, now I can write the automaton. I can compile it directly into it. So when I start, how many zeros have I seen? None. So let me put lambda since we learned just now that we can use lambda for none. That's my entry state. Now the next input is a one. How many zeros have I seen? None. The next input is a zero. How many zeros have I seen? Now I'm in my zero state. I see a one. How many zeros have I seen so far in a row? Nothing. I have to reset because I'm looking for zero, zero, one. If I see a one and I had not enough zeros, then I can't accept. And I have to reset my counter, I need to look for the zeros again. The one zero that I found no longer counts. And if I see a zero instead, my counter goes up by two. In this case, if I see a one, well, then I accept. And if I see a zero, then how many zeros have I seen so far? Well, one more, three. But I don't want to have too many states. And I know, well, it's not that I've seen three. I don't really care. More than two in a row is enough. So my zero, zero will be just the counter that instead of overflowing is saturated. So as soon as it gets to two, plus one keeps it at two. And then at the end here, whenever I've seen one substring zero, zero, one, I just have to eat the rest of an input so that I consume it and say everything is fine. So it just gets stuck. And this is my atomic. So again, in a simple case, you can think about it in terms of just draw the picture and put arrows and see what works, what doesn't. It will be better if you have some intuition. For simple things, you can use enums. This is perfectly fine. I wanted to get an answer that, well, the enums come because of counting and you're either overflowing or saturating. And to me, that's an easier way to think. And then you compile the counter down to bits, show that, yeah, in this case, I don't need an arbitrary size counter. And hopefully we got something similar to this. And if we want to complement, we just flip. Now, that's it for finite automata. That's our assembler language. That's where we compile into. We sort of understand what it is. The problem is that regular expressions are difficult to compile into automata. The big reason why regular expressions are difficult to compile into an automata is because of the choice. We have either a star. I don't know how many things repeat. They can repeat arbitrary number of times. Or we have a bar. I have a choice. Do one or the other. Those things are hard to compile into a deterministic machine. And so instead of doing it, we're going to do it in two steps. We're going to introduce a machine that allows for non-determinism. And then we're going to show that we can convert regular expression to this machine. And we can compile that machine into a finite automata. So that's going to be our intermediate layer. The definition is exactly the same. It's exactly the same as a D of A with one exception. Now, on one state, we can have multiple transitions on the same letter. That's the only difference. This is the simplest example you can have. In Q0, on letter A, we can go up or we can go down. Both choices are possible. Where do we go? We don't know. It's non-deterministic. Not random. Not some probability. It's non-deterministic. From the automata perspective, non-deterministic means that if there is a way to go in such a way that we accept a string, then that's where we go. Or if there is an oracle, some external entity that knows the input that is being given to us and knows our automata, the oracle can guide us and say, you know what, right now, better to go up or down. And if an oracle can guide us, we accept. That's what non-determinism means. So, for example, this automaton, does it accept the string single A? No? Because if I use U as an oracle, if you tell me to go down, I get to a rejecting state. No. If you tell me to go up, I get to a rejecting state. Also no. But this automaton accepts double A. Because if you know it's going to be double A, you tell me to go up, I go Q1, I go to Q2, and accept. That's how it works. You don't have to worry who makes the decision, how the oracle knows. If there is an oracle, that's good enough. You can also think about it that this is done with backtracking. The automaton first goes into one direction, and if it hits a roadblock, it can backtrack to the last place where it could make the choice, makes a different choice. And as long as it can make a choice eventually, it accepts. So this is non-deterministic automata. So this is this. OK. So it accepts the string if it's possible. Rejects the single A. We just saw that. And so the language here is double A. See that? Now, there's two special things that we do with this automaton. This automaton will be our surface language. So we're going to add features which are convenient for us. Makes it even harder to execute, but very convenient for us to model. And there's going to be two of them. One is we're going to allow lambda, or as you see in other slides, epsilon transition. That means an automaton can move from one state to another without reading anything from the input. This will be very convenient when we're going to build an automaton out of pieces. If I have an automaton for one piece, an automaton for another piece, and I kind of want to say, oh, as soon as you've finished one, start another. Instead of somehow gluing the states, I'm just going to get an epsilon transition between them. And it just says, oh, once you've finished one, sort of call the other and start running it. So the epsilon transition is just the glue. The second simplification that we're going to make is we're no longer going to draw transitions from every state. If there is a state, a letter, and no transition, we're going to say that it implicitly goes to some error state. So whenever you come to a state and a letter that has no transition, it simply means that from this point on you reject. In DfAs, because it's our underlying assembly line, which we have a complete table, in the picture it looks like whenever something goes wrong, we always go into the sink state with a self loop in it. That's very hard to draw. That's very ugly. That's very confusing. It's convenient once you create it as a table, because you know for sure what happens, there's no assumption. But as you draw it, it's inconvenient. For DfAs, we're going to drop this. So you only have to show transitions that matter. Any transitions that you don't show simply means it goes implicitly to this rejecting state. And so with this, we're going to get to one last thing. So we have this notion of regular languages. We talked about regular expressions. We've heard the words regular before. It's not surprising that all of those things are connected. We give different names to languages. And in particular, we say a language is regular if you can recognize it by a finite automaton. That is, a language is regular if you can write a recognizer for it with finite amount of memory and simple states. That's what makes it regular. So we've seen a whole bunch of examples of regular languages. We've seen one example, which is a and bn, of a non-regular language. This is something that you cannot recognize without arbitrary amount of memory, because you need to count how many a's you have, and you may need more memory. And we'll see a and bn later as well. Now, the fun part is this connection between regular expressions and regular languages. This is going to be our key theorem. It says that the two are equivalent. The reason why we call regular expressions regular is because this is a little programming language, whose semantics is exactly the regular languages, exactly what's represented by automaton. This theorem tells us that we can compile regular expressions into automaton, and we can decompile automaton into regular expressions. They are one and the same. They are just different presentations of them. Now, proof of this theorem obviously goes in two directions because of equality, compilation and decompilation. We're only going to do the compilation part here. That's actually the easy part. That's the part that's relevant. That's what we use in the compilers. The decompilation part is convenient because it then tells us, while regular language is really enough, that is, by requiring users to write their tokenizer as a regular expression, I'm not taking away any of their power if they want their lecture to be efficient. Because as long as they want the lecture to use finite amount of memory and be the simple program, while then if they say, well, I can do it with a regular expression, let me just program it, the theorem says, no, no, you can write a regular expression that will give you exactly the same program. But the proof that we're going to do is going to go in one direction. And we do it constructively by showing how to compile regular expressions to DFA. As I said, there's going to be three parts, which actually very nicely mimics what a compiler does in lots of places. First, we have a very simple, and it's so simple we still have like four minutes, we'll do it today. How do you go from regular expressions to NFA? The second part will be hard, that will take us to the next lecture, which is how you go from NFA, the non-deterministic automaton, to a deterministic one, how do you compile it down to our lower language. And then the next step, the last step, won't be too hard, but it will show you how we can go from a DFA of arbitrary size to the smallest one, the one that has the fewest number of states, fewest number of state variables, but is equivalent. We do it in these layers because then it's easy for us to prove that things are correct. It's not going to be the most efficient way to do it, because we're going to have a fairly big blow up in the middle, but it's going to be easier to guarantee that it is correct. Most of the time, this actually will also run efficiently enough, but if we need it to be more efficient, we can then later work in trying to optimize the steps, but we're going to have a reference implementation that it's easy to guarantee that it is correct. So we're going to do the transformation, and the transformation is in the other set of slides here. And as I said, the transformation is going to go syntax. It's a bottom-up syntactic construction, which means I show you how to construct an automaton for every little piece of a regular expression, and then we just connect them together through traversing the AST of the regular expression. The simplest one is for a single letter. If I have a regular expression which is just letter X, the automaton is just I eat X and that's it. Nothing. The next one is for concatenation. If I have two automaton, M of X and M of Y, which is two arbitrary automaton, and one accepts regular expression X, one accepts regular expression Y. If I want to accept one after another, I just stick them together, and I use my lambda transitions to connect them. I have a lambda transition to jump into the initial state of the first, a lambda or an epsilon transition to jump between, and to connect to the third. Now finally, the hard part, alternation. So if I have two regular expressions X and Y, I already build machines for them, and then I want to say accept either X or Y. Well, that's easy. I just have two epsilon transitions out of a single state, non-deterministically running one or the other, and then converge. Some oracle will come and say in any given input which one to use, X or Y, whichever one is appropriate for that input. Finally, if I have a star, it's the same thing. I just have to have enough epsilon transitions to say that my machine, M, can repeat itself arbitrary many times. That's it. So let's just do an example, and we'll be done. So say I have this, A or AB star. I want to get an automaton for it. This one is simple enough. You can just think and draw your own automaton. But if we follow the structure, then it will be very easy to see that we accept exactly this. We don't have to do any thinking. It's just going to be structurally exactly the same, just an automaton. So I start bottom up. I have three basic things here, two A's and a B. I start drawing them. This is for the top A. This is for the bottom A. This is for the bottom B. My volume B is in a star. So I need to take the B machine and say it can be run a whole bunch of times, non-deterministically. I add an extra state before and after. And then I use my epsilon transitions to keep running it. I can run it zero times. I can run it one time. And after the one time, I can repeat. The structure that I drew is exactly like the template that I showed before. You can think about it or you can just copy the template. All that it's doing, it says go into B, do it once, repeat if you want many times, skip over. That's a B star. Now I need A, B star. So now I need to do this guy. Just connect this with an epsilon transition. Again, by looking at my picture and matching up it to the regular expression, you can see it just match up. You don't need to think whether it is a correct automata or not. You just match up and you say it's correct because you're applying the rules that you're claiming to be correct. Next I need to do an OR. I have two states. I have an epsilon transition in, an epsilon transition in, an epsilon transition out, an epsilon transition out. And this light state is accepting. Here is my very complicated automaton for A or AB star. It's very complicated looking. It's very complicated to execute because of all of the epsilons. You have to think which way to go. It's very easy to tell that it's constructed according to the construction I promised. And so you can go from it to regular expression very easily. So you can match up. So for example, I made a mistake and put the wrong arrow. You could easily spot without even understanding what's going on. But it's hard to execute and it's big. But easy to build. Now we're going to show that we can make it deterministic so we can get rid of all of the epsilon transition in a very systematic way which will give us an automaton that's even harder to understand. But we'll not have any of this epsilon or non-deterministic transition. And then we'll show that we can minimize it. And once we minimize it, the minimizing algorithm is also not going to be very hard. And the minimal automaton that we'll get in this case will be something like... Like this. Like this. Like this. Like this. Like this. Like this. Like this. Right? Because you notice that A or AB star is the same as AB star. So this is what we desire to get. But if I were to do this one from the beginning, it's hard for me to argue that this is correct. Not open. So we're going to get here through minimization. Yep. Sorry. This loop? Yeah. You want it to go here? Shouldn't it be like that? Or... OK. So maybe I'm a little bit optimizing. Yeah. Probably. Let's see. Well, like it... Yeah. It doesn't... It sure goes here. So the question is whether this M has a single entry point or multiple. If it has multiple entry points, then obviously this epsilon has to have many epsilons going to different entry points. And so it's easier then for me to have this new state. It has all of the epsilons to the entry points. But it doesn't change. It's exactly the same. If this would go back to... If this guy goes here, then by epsilon, I didn't go here. That's it. Or I... All right. So tomorrow we're going to have a lab lecture. So you get to forget all of this. And then next month, you get to remember all of this. And we're going to do the compilation and minimization. Yay! Yay! Thank you! Thank you! Thank you! All right, so tomorrow we're gonna have a lab lecture, so you get to forget all of this, and then next month you get to remember all of this, and we're gonna do the compilation and minimization. Yay. Yay.